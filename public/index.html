<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Mapa Conceptual Animado</title>

  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body {
      font-family: 'Nunito', system-ui, sans-serif;
      margin: 20px;
      background-color: #121212;
      color: #f0f0f0;
    }

    h2 { color: #bb86fc; }

    input, button {
      background-color: #1e1e1e;
      color: #f0f0f0;
      border: 1px solid #444;
      padding: 8px 12px;
      border-radius: 6px;
      margin-right: 10px;
    }

    #tree-container {
      width: 100%;
      height: 700px;
      border: 1px solid #333;
      margin-top: 20px;
      overflow: hidden;
      background-color: #1e1e1e;
      border-radius: 8px;
    }

    svg { width: 100%; height: 100%; }

    .node rect {
      fill: #bb86fc;
      stroke: #fff;
      stroke-width: 1.5px;
      cursor: pointer;
    }

    .node text {
      font: 16px 'Nunito', sans-serif;
      fill: #f0f0f0;
      pointer-events: none;
      letter-spacing: 0.5px;
    }

    .link {
      fill: none;
      stroke: magenta;
      stroke-width: 1.5px;
    }
  </style>
</head>
<body>
<h2>Mapa Conceptual Animado</h2>
<input type="file" id="fileInput" accept=".csv" />
<button onclick="loadFromFile()">Cargar CSV y Generar Grafo</button>

<div id="tree-container">
  <svg id="tree"><g id="viewport"></g></svg>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const width = 2000, height = 2000;
const svg = d3.select("#tree").attr("viewBox", [0, 0, width, height]);
const viewport = d3.select("#viewport");

const zoom = d3.zoom().scaleExtent([0.3, 3])
  .on("zoom", ({ transform }) => viewport.attr("transform", transform));
svg.call(zoom);

let rootNode = null;
let i = 0;

// 游댢 Ajust치 ac치 los caracteres por l칤nea y m치rgenes
const MAX_CHARS_PER_LINE = 45;
const CHAR_WIDTH = 9;
const LINE_HEIGHT = 20;
const RECT_MARGIN_H = 40;
const RECT_MARGIN_V = 10;
const EXTRA_VERTICAL_GAP = 20;

function splitText(text, maxChars = MAX_CHARS_PER_LINE) {
  const regex = new RegExp(`.{1,${maxChars}}`, 'g');
  return text.match(regex) || [];
}

function rectWidth(d) {
  return MAX_CHARS_PER_LINE * CHAR_WIDTH + RECT_MARGIN_H;
}

function rectHeight(d) {
  const lines = splitText(d.data.name);
  return lines.length * LINE_HEIGHT + RECT_MARGIN_V;
}

function findOrCreate(parent, name) {
  if (!parent.children) parent.children = [];
  let existing = parent.children.find(c => c.name === name);
  if (!existing) {
    existing = { name, children: [] };
    parent.children.push(existing);
  }
  return existing;
}

function collapse(d) {
  if (d.children) {
    d._children = d.children;
    d._children.forEach(collapse);
    d.children = null;
  }
}

function focusOnNode(d) {
  const scale = 1.5;
  svg.transition().duration(750)
    .call(zoom.transform, d3.zoomIdentity
      .translate(
        document.getElementById("tree-container").clientWidth / 2 - d.y * scale,
        document.getElementById("tree-container").clientHeight / 2 - d.x * scale
      )
      .scale(scale));
}

const treeLayout = d3.tree();

function adjustVerticalSpacing(root) {
  root.eachAfter(node => {
    if (node.children && node.children.length > 1) {
      const siblings = node.children;
      siblings.forEach((child, idx) => {
        if (idx > 0) {
          const prev = siblings[idx - 1];
          const gap = rectHeight(prev) / 2 + rectHeight(child) / 2 + EXTRA_VERTICAL_GAP;
          child.x = prev.x + gap;
        }
      });
    }
  });
}

function update(source) {
  treeLayout.nodeSize([70, rectWidth(source) + 120]);
  treeLayout(rootNode);
  adjustVerticalSpacing(rootNode);

  const links = rootNode.links();
  const link = viewport.selectAll(".link").data(links, d => d.target.id);

  link.exit().transition().duration(750).style("opacity", 0).remove();

  link.enter().append("path")
    .attr("class", "link")
    .merge(link)
    .transition().duration(750)
    .attr("d", d => {
      const sourceWidth = rectWidth(d.source);
      return d3.linkHorizontal()
        .x(n => n.y + (n === d.source ? sourceWidth : 0))
        .y(n => n.x)(d);
    });

  const nodes = rootNode.descendants();
  const node = viewport.selectAll(".node").data(nodes, d => d.id || (d.id = ++i));

  const nodeEnter = node.enter().append("g")
    .attr("class", "node")
    .attr("transform", d => `translate(${source.y0 || 0},${source.x0 || 0})`)
    .style("opacity", 0)
    .on("click", (event, d) => {
      if (d.children) {
        d._children = d.children;
        d.children = null;
      } else if (d._children) {
        d.children = d._children;
        d._children = null;
      }
      update(d);
      focusOnNode(d);
    });

  nodeEnter.append("rect")
    .attr("width", rectWidth)
    .attr("height", rectHeight)
    .attr("x", 0)
    .attr("y", 0)
    .attr("rx", 6).attr("ry", 6);

  nodeEnter.each(function(d) {
    const g = d3.select(this);
    const lines = splitText(d.data.name);
    lines.forEach((line, i) => {
      g.append("text")
        .attr("x", 10)
        .attr("y", i * LINE_HEIGHT + 20)
        .text(line);
    });
  });

  const nodeUpdate = nodeEnter.merge(node);
  nodeUpdate.transition()
    .duration(750)
    .attr("transform", d => `translate(${d.y},${d.x})`)
    .style("opacity", 1);

  node.exit().transition().duration(750)
    .attr("transform", d => `translate(${source.y},${source.x})`)
    .style("opacity", 0)
    .remove();

  nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });

  if (source === rootNode) {
    const box = viewport.node().getBBox();
    const scale = Math.min(
      document.getElementById("tree-container").clientWidth / box.width,
      document.getElementById("tree-container").clientHeight / box.height,
      1.5
    );
    const translateX = (document.getElementById("tree-container").clientWidth - box.width * scale) / 2 - box.x * scale;
    const translateY = 20;
    svg.transition().duration(750)
      .call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));
  }
}

function loadFromFile() {
  const input = document.getElementById('fileInput');
  if (!input.files.length) {
    alert("Por favor seleccion치 un archivo CSV primero.");
    return;
  }
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = function(e) {
    const text = e.target.result;
    try {
      const data = d3.csvParse(text);
      const treeData = { name: "Empresas", children: [] };

      data.forEach(row => {
        const vendedor = row["Vendedor"]?.trim() || "Sin Vendedor";
        const fecha = row["Fecha de Status"]?.trim() || "Sin Fecha";
        const cliente = row["Cliente"]?.trim() || "Sin Cliente";
        const pais = row["Pa칤s"]?.trim() || "Sin Pa칤s";
        const tipo = row["Tipo de Proyecto"]?.trim() || "Sin Tipo";
        const estado = row["Estado"]?.trim() || "Sin Estado";
        const responsable = row["Responsable"]?.trim() || "Sin Responsable";
        const status = row["Status"]?.trim() || "Sin Status";

        const vendedorNode = findOrCreate(treeData, vendedor);
        const fechaNode = findOrCreate(vendedorNode, fecha);
        const clienteNode = findOrCreate(fechaNode, cliente);

        [pais, tipo, estado, responsable, status].forEach(nombre => {
          if (!clienteNode.children.find(c => c.name === nombre)) {
            clienteNode.children.push({ name: nombre, children: [] });
          }
        });
      });

      rootNode = d3.hierarchy(treeData);
      rootNode.x0 = height / 2;
      rootNode.y0 = 0;
      rootNode.children.forEach(collapse);
      update(rootNode);

    } catch (error) {
      alert("Error al procesar CSV: " + error);
    }
  };
  reader.readAsText(file);
}
</script>
</body>
</html>
