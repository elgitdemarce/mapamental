<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Mapa Conceptual Animado</title>

  <!-- Fuente Nunito -->
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body {
      font-family: 'Nunito', system-ui, sans-serif;
      margin: 20px;
      background-color: #121212;
      color: #f0f0f0;
    }

    h2 {
      color: #bb86fc;
      letter-spacing: 0.5px;
    }

    input, button {
      background-color: #1e1e1e;
      color: #f0f0f0;
      border: 1px solid #444;
      padding: 8px 12px;
      border-radius: 6px;
      margin-right: 10px;
    }

    input:hover, button:hover {
      background-color: #2a2a2a;
    }

    #tree-container {
      width: 100%;
      height: 700px;
      border: 1px solid #333;
      margin-top: 20px;
      overflow: hidden;
      background-color: #1e1e1e;
      border-radius: 8px;
    }

    svg {
      width: 100%;
      height: 100%;
    }

    .node rect {
      fill: #bb86fc;
      stroke: #fff;
      stroke-width: 1.5px;
      cursor: pointer;
    }

    .node text {
      font: 16px 'Nunito', sans-serif;
      fill: #f0f0f0;
      pointer-events: none;
      letter-spacing: 0.5px;
    }

    .link {
      fill: none;
      stroke: magenta;
      stroke-width: 1.5px;
    }
  </style>
</head>
<body>

<h2>Mapa Conceptual Animado</h2>
<input type="file" id="fileInput" accept=".csv" />
<button onclick="loadFromFile()">Cargar CSV y Generar Grafo</button>

<div id="tree-container">
  <svg id="tree"><g id="viewport"></g></svg>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const width = 2000, height = 2000;
const svg = d3.select("#tree").attr("viewBox", [0, 0, width, height]);
const viewport = d3.select("#viewport");

const zoom = d3.zoom().scaleExtent([0.3, 3])
  .on("zoom", ({ transform }) => viewport.attr("transform", transform));
svg.call(zoom);

let rootNode = null;
let i = 0;
const MAX_CHARS_PER_LINE = 40;

function splitText(text, maxChars = MAX_CHARS_PER_LINE) {
  const regex = new RegExp(`.{1,${maxChars}}`, 'g');
  return text.match(regex) || [];
}

function rectWidth(d) {
  const lines = splitText(d.data.name);
  const maxLine = Math.max(...lines.map(l => l.length));
  return maxLine * 9 + 40;
}

function findOrCreate(parent, name) {
  if (!parent.children) parent.children = [];
  let existing = parent.children.find(c => c.name === name);
  if (!existing) {
    existing = { name, children: [] };
    parent.children.push(existing);
  }
  return existing;
}

function collapse(d) {
  if (d.children) {
    d._children = d.children;
    d._children.forEach(collapse);
    d.children = null;
  }
}

function focusOnNode(d) {
  const scale = 1.5;
  svg.transition().duration(750)
    .call(zoom.transform, d3.zoomIdentity
      .translate(
        document.getElementById("tree-container").clientWidth / 2 - d.y * scale,
        document.getElementById("tree-container").clientHeight / 2 - d.x * scale
      )
      .scale(scale));
}

// ---- Tree Layout con separaci칩n din치mica ----
const treeLayout = d3.tree();

function update(source) {
  const allNodes = rootNode.descendants();
  const maxNodeWidth = Math.max(...allNodes.map(rectWidth));

  // 游댠 Nueva separaci칩n din치mica
  treeLayout
    .nodeSize([1, maxNodeWidth + 120])
    .separation((a, b) => {
      if (a.parent === b.parent) {
        const aHeight = splitText(a.data.name).length * 20 + 30;
        const bHeight = splitText(b.data.name).length * 20 + 30;
        return (aHeight + bHeight) / 70; // separaci칩n proporcional
      }
      return 1.5; // ramas distintas m치s separadas
    });

  treeLayout(rootNode);

  // ---- LINKS ----
  const links = rootNode.links();
  const link = viewport.selectAll(".link").data(links, d => d.target.id);

  link.exit().transition().duration(750).style("opacity", 0).remove();

  link.enter()
    .append("path")
    .attr("class", "link")
    .merge(link)
    .transition().duration(750)
    .attr("d", d => {
      const sourceWidth = rectWidth(d.source);
      return d3.linkHorizontal()
        .x(node => node.y + (node === d.source ? sourceWidth : 0))
        .y(node => node.x)(d);
    });

  // ---- NODES ----
  const nodes = rootNode.descendants();
  const node = viewport.selectAll(".node").data(nodes, d => d.id || (d.id = ++i));

  const nodeEnter = node.enter()
    .append("g")
    .attr("class", "node")
    .attr("transform", d => `translate(${source.y0 || 0},${source.x0 || 0})`)
    .style("opacity", 0)
    .on("click", (event, d) => {
      if (d.children) {
        d._children = d.children;
        d.children = null;
      } else if (d._children) {
        d.children = d._children;
        d._children = null;
      }
      update(d);
      focusOnNode(d);
    });

  nodeEnter.append("rect")
    .attr("width", rectWidth)
    .attr("height", d => {
      const lines = splitText(d.data.name);
      return lines.length * 20 + 10;
    })
    .attr("x", 0)
    .attr("y", 0)
    .attr("rx", 6)
    .attr("ry", 6);

  nodeEnter.each(function(d) {
    const g = d3.select(this);
    const lines = splitText(d.data.name);
    lines.forEach((line, i) => {
      g.append("text")
        .attr("x", 10)
        .attr("y", i * 20 + 20)
        .style("text-anchor", "start")
        .text(line);
    });
  });

  const nodeUpdate = nodeEnter.merge(node);
  nodeUpdate.transition()
    .duration(750)
    .attr("transform", d => `translate(${d.y},${d.x})`)
    .style("opacity", 1);

  node.exit().transition().duration(750)
    .attr("transform", d => `translate(${source.y},${source.x})`)
    .style("opacity", 0)
    .remove();

  nodes.forEach(d => {
    d.x0 = d.x;
    d.y0 = d.y;
  });

  // 游댠 Zoom inicial al cargar todo
  if (source === rootNode) {
    const box = viewport.node().getBBox();
    const scale = Math.min(
      document.getElementById("tree-container").clientWidth / box.width,
      document.getElementById("tree-container").clientHeight / box.height,
      1.5
    );
    const translateX = (document.getElementById("tree-container").clientWidth - box.width * scale) / 2 - box.x * scale;
    const translateY = 20;
    svg.transition().duration(750)
      .call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));
  }
}

function loadFromFile() {
  const input = document.getElementById('fileInput');
  if (!input.files.length) {
    alert("Por favor seleccion치 un archivo CSV primero.");
    return;
  }
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = function(e) {
    const text = e.target.result;
    try {
      const data = d3.csvParse(text);

      const treeData = { name: "Empresas", children: [] };

      data.forEach(row => {
        const vendedor = row["Vendedor"]?.trim() || "Sin Vendedor";
        const fecha = row["Fecha de Status"]?.trim() || "Sin Fecha";
        const cliente = row["Cliente"]?.trim() || "Sin Cliente";
        const pais = row["Pa칤s"]?.trim() || "Sin Pa칤s";
        const tipo = row["Tipo de Proyecto"]?.trim() || "Sin Tipo";
        const estado = row["Estado"]?.trim() || "Sin Estado";
        const responsable = row["Responsable"]?.trim() || "Sin Responsable";
        const status = row["Status"]?.trim() || "Sin Status";

        const vendedorNode = findOrCreate(treeData, vendedor);
        const fechaNode = findOrCreate(vendedorNode, fecha);
        const clienteNode = findOrCreate(fechaNode, cliente);

        [pais, tipo, estado, responsable, status].forEach(nombre => {
          if (!clienteNode.children.find(c => c.name === nombre)) {
            clienteNode.children.push({ name: nombre, children: [] });
          }
        });
      });

      rootNode = d3.hierarchy(treeData);
      rootNode.x0 = height / 2;
      rootNode.y0 = 0;
      rootNode.children.forEach(collapse);
      update(rootNode);

    } catch (error) {
      alert("Error al procesar CSV: " + error);
    }
  };
  reader.readAsText(file);
}
</script>

</body>
</html>
