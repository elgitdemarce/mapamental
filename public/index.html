<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Mapa Conceptual Mejorado</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Nunito', sans-serif;
      background: #121212;
      color: #fff;
      margin: 20px;
    }
    h2 { color: #bb86fc; }
    input, button {
      background: #1e1e1e;
      color: #fff;
      border: 1px solid #444;
      padding: 8px 12px;
      border-radius: 6px;
      margin-right: 10px;
    }
    #tree-container {
      width: 100%;
      height: 700px;
      background: #1e1e1e;
      border: 1px solid #333;
      border-radius: 6px;
      margin-top: 20px;
      overflow: hidden;
    }
    .node rect {
      fill: #bb86fc;
      stroke: #fff;
      stroke-width: 1.5px;
    }
    .node text {
      fill: #fff;
      font: 16px 'Nunito', sans-serif;
      letter-spacing: 0.5px;
      pointer-events: none;
    }
    .link {
      fill: none;
      stroke: magenta;
      stroke-width: 1.5px;
    }
  </style>
</head>
<body>
<h2>Mapa Conceptual Mejorado</h2>
<input type="file" id="fileInput" accept=".csv">
<button onclick="loadFromFile()">Cargar CSV</button>
<div id="tree-container"><svg id="tree"><g id="viewport"></g></svg></div>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const width = 2000, height = 2000;
const svg = d3.select("#tree").attr("viewBox", [0, 0, width, height]);
const viewport = d3.select("#viewport");

const zoom = d3.zoom().scaleExtent([0.3, 3])
  .on("zoom", ({transform}) => viewport.attr("transform", transform));
svg.call(zoom);

let rootNode = null, i = 0;

// === CONFIGURACIÓN DE NODOS ===
const MAX_CHARS_PER_LINE = 45;
const CHAR_WIDTH = 9;
const LINE_HEIGHT = 20;
const RECT_MARGIN_H = 40;
const RECT_MARGIN_V = 10;

function splitText(text, maxChars=MAX_CHARS_PER_LINE){
  const regex=new RegExp(`.{1,${maxChars}}`,'g');
  return text.match(regex)||[];
}

function rectWidth(d){ 
  // Ajuste dinámico para que los nodos largos tengan más ancho si es necesario
  const lines = splitText(d.data.name);
  const maxLine = Math.max(...lines.map(l => l.length));
  return Math.max(maxLine * CHAR_WIDTH + RECT_MARGIN_H, MAX_CHARS_PER_LINE * CHAR_WIDTH + RECT_MARGIN_H);
}

function rectHeight(d){
  const lines = splitText(d.data.name);
  return lines.length*LINE_HEIGHT+RECT_MARGIN_V;
}

function findOrCreate(parent, name){
  if(!parent.children) parent.children=[];
  let existing=parent.children.find(c=>c.name===name);
  if(!existing){ existing={name,children:[]}; parent.children.push(existing);}
  return existing;
}

function collapse(d){
  if(d.children){ d._children=d.children; d._children.forEach(collapse); d.children=null; }
}

function focusOnNode(d){
  const scale=1.5;
  svg.transition().duration(750)
    .call(zoom.transform,d3.zoomIdentity
      .translate(document.getElementById("tree-container").clientWidth/2 - d.y*scale,
                 document.getElementById("tree-container").clientHeight/2 - d.x*scale)
      .scale(scale));
}

// === TREE LAYOUT con separación dinámica según altura ===
const treeLayout = d3.tree()
  .nodeSize([70, 200])
  .separation((a, b) => {
    return (a.parent === b.parent ? 1 : 1.5) +
           (rectHeight(a) + rectHeight(b)) / 120;
  });

function update(source){
  treeLayout(rootNode);

  const link = viewport.selectAll(".link")
    .data(rootNode.links(), d=>d.target.id);

  link.exit().transition().duration(750).style("opacity",0).remove();
  link.enter().append("path").attr("class","link")
    .merge(link)
    .transition().duration(750)
    .attr("d", d=>{
      const sourceWidth=rectWidth(d.source);
      return d3.linkHorizontal()
        .x(n=>n.y+(n===d.source?sourceWidth:0))
        .y(n=>n.x)(d);
    });

  const node = viewport.selectAll(".node")
    .data(rootNode.descendants(), d=>d.id||(d.id=++i));

  const nodeEnter=node.enter().append("g")
    .attr("class","node")
    .attr("transform",d=>`translate(${source.y0||0},${source.x0||0})`)
    .style("opacity",0)
    .on("click",(e,d)=>{
      if(d.children){d._children=d.children; d.children=null;}
      else if(d._children){d.children=d._children; d._children=null;}
      update(d); focusOnNode(d);
    });

  nodeEnter.append("rect")
    .attr("rx",6).attr("ry",6)
    .attr("width", rectWidth)
    .attr("height", rectHeight);

  nodeEnter.each(function(d){
    const g=d3.select(this), lines=splitText(d.data.name);
    lines.forEach((line,i)=>{
      g.append("text").attr("x",10).attr("y",i*LINE_HEIGHT+20).text(line);
    });
  });

  nodeEnter.merge(node).transition().duration(750)
    .attr("transform",d=>`translate(${d.y},${d.x})`).style("opacity",1);

  node.exit().transition().duration(750)
    .attr("transform",d=>`translate(${source.y},${source.x})`).style("opacity",0).remove();

  rootNode.descendants().forEach(d=>{d.x0=d.x; d.y0=d.y;});

  if(source===rootNode){
    const box=viewport.node().getBBox();
    const scale=Math.min(
      document.getElementById("tree-container").clientWidth/box.width,
      document.getElementById("tree-container").clientHeight/box.height,
      1.5
    );
    const translateX=(document.getElementById("tree-container").clientWidth - box.width*scale)/2 - box.x*scale;
    const translateY=20;
    svg.transition().duration(750)
      .call(zoom.transform,d3.zoomIdentity.translate(translateX,translateY).scale(scale));
  }
}

function loadFromFile(){
  const input=document.getElementById('fileInput');
  if(!input.files.length){alert("Seleccione un CSV");return;}
  const reader=new FileReader();
  reader.onload=function(e){
    const text=e.target.result;
    const data=d3.csvParse(text);
    const treeData={name:"Empresas",children:[]};
    data.forEach(row=>{
      const vendedor=row["Vendedor"]?.trim()||"Sin Vendedor";
      const fecha=row["Fecha de Status"]?.trim()||"Sin Fecha";
      const cliente=row["Cliente"]?.trim()||"Sin Cliente";
      const pais=row["País"]?.trim()||"Sin País";
      const tipo=row["Tipo de Proyecto"]?.trim()||"Sin Tipo";
      const estado=row["Estado"]?.trim()||"Sin Estado";
      const responsable=row["Responsable"]?.trim()||"Sin Responsable";
      const status=row["Status"]?.trim()||"Sin Status";

      const vNode=findOrCreate(treeData,vendedor);
      const fNode=findOrCreate(vNode,fecha);
      const cNode=findOrCreate(fNode,cliente);
      [pais,tipo,estado,responsable,status].forEach(n=>{
        if(!cNode.children.find(c=>c.name===n))
          cNode.children.push({name:n,children:[]});
      });
    });
    rootNode=d3.hierarchy(treeData);
    rootNode.x0=height/2; rootNode.y0=0;
    rootNode.children.forEach(collapse);
    update(rootNode);
  };
  reader.readAsText(input.files[0]);
}
</script>
</body>
</html>
